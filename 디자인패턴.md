# [1장. 설계패턴 소개]
□ 배경
 - 패턴 : 맥락에서 문제를 해결위한 솔루션
 - 건축에서 시작 -> IT에 접목
 - Gang of Four 에서 디자인 패턴의 개념이 만들어짐

□ 장점
 - 재사용
 - 잘 만들어진, 유연한, 재사용가능한
 - 개발자간 의사소통 수단
 - 누군자 해결한 솔루션을 활용

□ 구성 : context, problem, solution

□ 예시 (iterator)
 - context : 객체의 집합이 있음
 - problem : 집합의 구현을 노출하지 않고 객체 운영필요
 - solution : 반복을 캡슐화

□ 목적으로 구분
 - Creational : 유연하게 생성, 생성/사용을 분리
 - Structural : 클래스와 객체를 조직화
 - Behavioral : 클래스간 관계,통신을 정의

□ scope로 구분
 - class
 - object

□ 디자인 패턴의 주요기능
 - 아키택처패턴 : 시스템 전체가 대상
 - 디자인 패턴 : 서브시스템, 컴포넌트 대상. 전체 구조에 영향끼치지 않는다.
 - 코딩 패턴 : low-level, programming language


# [2장. 객체지향 패러다임]
□ Abstract Data Type (ADT) : 데이터를 추상화 해서 단일 구성 유닛으로
 -> 클래스 개념이 여기서 파생됨
 
□ Class = ADT + Inheritance(재사용성) + Polymorphism(유연성)
 -> 클래스 내부 뿐 아니라 클라이언트 코드도 재사용 가능한지가 더 중요함
 
□ Inheritance (Y -> X)  
 - Y는 X의 모든 매소드/데이터 상속받음 >> Y는 X이다
   >> X타입이 되는곳은 모두 Y타입으로 대체가능
  
□ Polymorphism (다형성. 오퍼레이션이 다른 방식으로 구성될 수 있다)
 - Runtime polymorphism : 오버라이딩 - 하위 클래스에서 상위 클래스의 매소드를 사용/재정의 가능
 - Compile polymorphism : 오버로딩 - 같은 이름의 다른 매개변수를 가진 매소드

□ Runtime polymorphism (Y -> X) 일때
 - X a = new X() 이라면
 - X b = new Y() 가능
 - Y c = new X() 불가능

 - 런타임에 자기에게 맞는 메소드를 바인딩한다
 - 개발 및 유지보수에 유용

□ abstract Class / Method
 - 추상매소드는 body가 없음
 - 추상클래스는 abstract 키워드로 선언
 - abstract 매소드를 하나라도 가지면 abstract 클래스여야 한다 (반대는아님)
 - 추상클래스는 인스턴스를 만들 수 없다
 - 추상클래스 타입의 변수도 하위의 일반클래스를 가리킬 수 있다

□ 어떤 매소드가 실행도록 만드는지 결정
 1. 현재 클래스에 매소드가 있으면 실행
 2. 없으면 상위 클래스로 찾아 올라감
 3. 만약 최상위까지 올라가도 없는것은 불가능 (컴파일 에러)
 
□ Interface란?
 - 모든 매소드는 추상
 - 인스턴스값을 가질 수 없음
 - public static final variable 은 가질 수 있다.
 - 추상클래스보다도 더 추상적
 - interface 키워드로 정의
 - implements 키워드로 상속받음

□ 추상클래스와 인터페이스 비교
 - 가능하면 인터페이스를 사용하라
 - 추상클래스를 사용하는 경우 : 부모자식관계, 부분적인 implementation을 써야 하는 경우
 - 인터페이스를 사용하는 경우 : 대부분

□ 상위레벨의 인스턴스일수록 다양한 타입의 인스턴스를 가리킬 수 있어서 범용으로 사용 가능
  하지만 무조건 상위 인스턴스를 사용하지 않는 이유는 (java의 경우 object)
  적절한 권한이나 능력을 가진것을 사용하기 위함

□ 클래스간 관계
 - 상위클래스의 변경은 하위 클래스로 영향을 줌
 - 반대로 하위클래스의 변경은 상위 클래스에 영향 
 - 가능하면 변경에 대한 영향이 적도록 디자인 (추상/인터페이스 활용)

□ 정보은닉
 - 외부와 연결되는 것은 인터페이스 등으로 하고
 - 하위의 변경을 외부에 보여지지 않도록 함

# [3장. SOLID Principle]
□ Disign Smell : 나쁜 디자인의 징후
 - 경직성, 취약성, 부동성, 점착성, 불필요한 복잡성, 불필요한 반복, 불투명성
 - 원인 : 잘못된 Dependencies
 - 해결 : 설계원칙을 준수

□ OOD Principles
 - SOLID, GRASP 등
 
□ SOLID 
 - Single-Responsibility (SRP) 단일책임
 - Open-Closed (OCP) 개방폐쇄
 - Liskov Substitution (LSP) 리스코프치환
 - Interface Segregation (ISP) 인터페이스 분리
 - Dependency Inversion (DIP) 의존성 역전

□ SRP
 - responsibility : 클래스가 해야 할 의무/일
 - 많은 책임 > 많은 변경 > 많은 버그
 - Cohesion : 응집도
 - 클래스 내 불필요한 기능은 별도로 분리필요
